// Code generated by github.com/tcard/make.go.mock. DO NOT EDIT.

package examples

import (
	fmt "fmt"
	cmp "github.com/google/go-cmp/cmp"
	os "os"
	runtime "runtime"
)

// MyInterfaceInCustomFileMocker builds mocks for type MyInterface.
//
// Its fields match the original type's methods. Set those you expect to be
// called, then call the Mock method to get a mock that implements the original
// type.
//
// If the original type was a function, it is mapped to field Func.
//
// The Describe method is a shortcut to define this struct's fields in a
// declarative manner.
type MyInterfaceInCustomFileMocker struct {
	Boring                 func()
	EmbeddedMethod         func()
	ReturnSomethingAtLeast func() (r0 int)
	ShouldBeFun            func(a0 int, a1 map[string]map[MyStruct]bool, a2 ...chan<- <-chan struct{}) (r0 int, r1 error)
	StdSomething           func(f *os.File, ints ...int) (named bool)
}

// Describe lets you describe how the methods on the resulting mock are expected
// to be called and what they will return.
//
// When you're done describing methods, call Mock to get a mock that implements
// the behavior you described.
func (m *MyInterfaceInCustomFileMocker) Describe() MyInterfaceInCustomFileMockDescriptor {
	return MyInterfaceInCustomFileMockDescriptor{m: m}
}

// A MyInterfaceInCustomFileMockDescriptor lets you describe how the methods on the resulting mock are expected
// to be called and what they will return.
//
// When you're done describing methods, call its Mock method to get a mock that
// implements the behavior you described.
type MyInterfaceInCustomFileMockDescriptor struct {
	m *MyInterfaceInCustomFileMocker
	descriptors_Boring []*MyInterfaceInCustomFileBoringMockDescriptor
	descriptors_EmbeddedMethod []*MyInterfaceInCustomFileEmbeddedMethodMockDescriptor
	descriptors_ReturnSomethingAtLeast []*MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor
	descriptors_ShouldBeFun []*MyInterfaceInCustomFileShouldBeFunMockDescriptor
	descriptors_StdSomething []*MyInterfaceInCustomFileStdSomethingMockDescriptor
}

// Mock returns a mock that the MyInterface interface, following the behavior
// described by the descriptor methods.
//
// It also returns a function that should be called before the test is done to
// ensure that the expected number of calls to the mock methods happened. You
// can pass a *testing.T to it, since it implements the interface it wants.
func (d MyInterfaceInCustomFileMockDescriptor) Mock() (m MyInterfaceInCustomFileMock, assert func(t interface{ Errorf(s string, args ...interface{})  }) (ok bool)) {
	assert = d.done()
	return d.m.Mock(), assert
}

func (d MyInterfaceInCustomFileMockDescriptor) done() func(t interface{ Errorf(s string, args ...interface{})  }) bool {
	var atAssert []func() (method string, errs []string)
	type specErrs struct {
		fileLine string
		errs []string
	}
	
	if len(d.descriptors_Boring) > 0 {
		for _, desc := range d.descriptors_Boring {
			desc := desc
			calls := 0
			desc.call = func() {
				calls++
			}
			atAssert = append(atAssert, func() (method string, errs []string) {
				err := desc.times(calls)
				if err != nil {
					return "Boring", []string{err.Error()}
				}
				return "", nil
			})
		}
		d.m.Boring = func() {
			var matching []*MyInterfaceInCustomFileBoringMockDescriptor
			var allErrs []specErrs
			for _, desc := range d.descriptors_Boring {
				errs := desc.argValidator()
				if len(errs) > 0 {
					allErrs = append(allErrs, specErrs{desc.fileLine, errs})
				} else {
					matching = append(matching, desc)
				}
			}
			if len(matching) == 1 {
				matching[0].call()
				return
			}
			var args string
			for i, arg := range []interface{}{} {
				if i != 0 {
					args += "\n\t"
				}
				args += fmt.Sprintf("%#v", arg)
			}
			if len(matching) == 0 {
				matchingErrs := ""
				for _, errs := range allErrs {
					matchingErrs += "\n\tcandidate described at "+errs.fileLine+":\n"
					for _, err := range errs.errs {
						matchingErrs += "\n\t\t" + err
					}
				}
				panic(fmt.Errorf("no matching candidate for call to mock for MyInterfaceInCustomFile.Boring with args:\n\n\t%+v\n\nfailing candidates:\n%s", args, matchingErrs))
			}
			matchingLines := ""
			for _, m := range matching {
				matchingLines += "\n\tcandidate described at " + m.fileLine
			}
			panic(fmt.Errorf("more than one candidate for call to mock for MyInterfaceInCustomFile.Boring with args:\n\n\t%+v\n\nmatching candidates:\n%s", args, matchingLines))
		}
	} else {
		d.m.Boring = func() {
			panic("unexpected call to mock for MyInterfaceInCustomFile.Boring")
		}
	}
	if len(d.descriptors_EmbeddedMethod) > 0 {
		for _, desc := range d.descriptors_EmbeddedMethod {
			desc := desc
			calls := 0
			desc.call = func() {
				calls++
			}
			atAssert = append(atAssert, func() (method string, errs []string) {
				err := desc.times(calls)
				if err != nil {
					return "EmbeddedMethod", []string{err.Error()}
				}
				return "", nil
			})
		}
		d.m.EmbeddedMethod = func() {
			var matching []*MyInterfaceInCustomFileEmbeddedMethodMockDescriptor
			var allErrs []specErrs
			for _, desc := range d.descriptors_EmbeddedMethod {
				errs := desc.argValidator()
				if len(errs) > 0 {
					allErrs = append(allErrs, specErrs{desc.fileLine, errs})
				} else {
					matching = append(matching, desc)
				}
			}
			if len(matching) == 1 {
				matching[0].call()
				return
			}
			var args string
			for i, arg := range []interface{}{} {
				if i != 0 {
					args += "\n\t"
				}
				args += fmt.Sprintf("%#v", arg)
			}
			if len(matching) == 0 {
				matchingErrs := ""
				for _, errs := range allErrs {
					matchingErrs += "\n\tcandidate described at "+errs.fileLine+":\n"
					for _, err := range errs.errs {
						matchingErrs += "\n\t\t" + err
					}
				}
				panic(fmt.Errorf("no matching candidate for call to mock for MyInterfaceInCustomFile.EmbeddedMethod with args:\n\n\t%+v\n\nfailing candidates:\n%s", args, matchingErrs))
			}
			matchingLines := ""
			for _, m := range matching {
				matchingLines += "\n\tcandidate described at " + m.fileLine
			}
			panic(fmt.Errorf("more than one candidate for call to mock for MyInterfaceInCustomFile.EmbeddedMethod with args:\n\n\t%+v\n\nmatching candidates:\n%s", args, matchingLines))
		}
	} else {
		d.m.EmbeddedMethod = func() {
			panic("unexpected call to mock for MyInterfaceInCustomFile.EmbeddedMethod")
		}
	}
	if len(d.descriptors_ReturnSomethingAtLeast) > 0 {
		for _, desc := range d.descriptors_ReturnSomethingAtLeast {
			desc := desc
			calls := 0
			prev := desc.call
			desc.call = func() (r0 int) {
				calls++
				return prev()
			}
			atAssert = append(atAssert, func() (method string, errs []string) {
				err := desc.times(calls)
				if err != nil {
					return "ReturnSomethingAtLeast", []string{err.Error()}
				}
				return "", nil
			})
		}
		d.m.ReturnSomethingAtLeast = func() (r0 int) {
			var matching []*MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor
			var allErrs []specErrs
			for _, desc := range d.descriptors_ReturnSomethingAtLeast {
				errs := desc.argValidator()
				if len(errs) > 0 {
					allErrs = append(allErrs, specErrs{desc.fileLine, errs})
				} else {
					matching = append(matching, desc)
				}
			}
			if len(matching) == 1 {
				return matching[0].call()
			}
			var args string
			for i, arg := range []interface{}{} {
				if i != 0 {
					args += "\n\t"
				}
				args += fmt.Sprintf("%#v", arg)
			}
			if len(matching) == 0 {
				matchingErrs := ""
				for _, errs := range allErrs {
					matchingErrs += "\n\tcandidate described at "+errs.fileLine+":\n"
					for _, err := range errs.errs {
						matchingErrs += "\n\t\t" + err
					}
				}
				panic(fmt.Errorf("no matching candidate for call to mock for MyInterfaceInCustomFile.ReturnSomethingAtLeast with args:\n\n\t%+v\n\nfailing candidates:\n%s", args, matchingErrs))
			}
			matchingLines := ""
			for _, m := range matching {
				matchingLines += "\n\tcandidate described at " + m.fileLine
			}
			panic(fmt.Errorf("more than one candidate for call to mock for MyInterfaceInCustomFile.ReturnSomethingAtLeast with args:\n\n\t%+v\n\nmatching candidates:\n%s", args, matchingLines))
		}
	} else {
		d.m.ReturnSomethingAtLeast = func() (r0 int) {
			panic("unexpected call to mock for MyInterfaceInCustomFile.ReturnSomethingAtLeast")
		}
	}
	if len(d.descriptors_ShouldBeFun) > 0 {
		for _, desc := range d.descriptors_ShouldBeFun {
			desc := desc
			calls := 0
			prev := desc.call
			desc.call = func(a0 int, a1 map[string]map[MyStruct]bool, a2 []chan<- <-chan struct{}) (r0 int, r1 error) {
				calls++
				return prev(a0, a1, a2)
			}
			atAssert = append(atAssert, func() (method string, errs []string) {
				err := desc.times(calls)
				if err != nil {
					return "ShouldBeFun", []string{err.Error()}
				}
				return "", nil
			})
		}
		d.m.ShouldBeFun = func(a0 int, a1 map[string]map[MyStruct]bool, a2 ...chan<- <-chan struct{}) (r0 int, r1 error) {
			var matching []*MyInterfaceInCustomFileShouldBeFunMockDescriptor
			var allErrs []specErrs
			for _, desc := range d.descriptors_ShouldBeFun {
				errs := desc.argValidator(a0, a1, a2)
				if len(errs) > 0 {
					allErrs = append(allErrs, specErrs{desc.fileLine, errs})
				} else {
					matching = append(matching, desc)
				}
			}
			if len(matching) == 1 {
				return matching[0].call(a0, a1, a2)
			}
			var args string
			for i, arg := range []interface{}{a0, a1, a2} {
				if i != 0 {
					args += "\n\t"
				}
				args += fmt.Sprintf("%#v", arg)
			}
			if len(matching) == 0 {
				matchingErrs := ""
				for _, errs := range allErrs {
					matchingErrs += "\n\tcandidate described at "+errs.fileLine+":\n"
					for _, err := range errs.errs {
						matchingErrs += "\n\t\t" + err
					}
				}
				panic(fmt.Errorf("no matching candidate for call to mock for MyInterfaceInCustomFile.ShouldBeFun with args:\n\n\t%+v\n\nfailing candidates:\n%s", args, matchingErrs))
			}
			matchingLines := ""
			for _, m := range matching {
				matchingLines += "\n\tcandidate described at " + m.fileLine
			}
			panic(fmt.Errorf("more than one candidate for call to mock for MyInterfaceInCustomFile.ShouldBeFun with args:\n\n\t%+v\n\nmatching candidates:\n%s", args, matchingLines))
		}
	} else {
		d.m.ShouldBeFun = func(a0 int, a1 map[string]map[MyStruct]bool, a2 ...chan<- <-chan struct{}) (r0 int, r1 error) {
			panic("unexpected call to mock for MyInterfaceInCustomFile.ShouldBeFun")
		}
	}
	if len(d.descriptors_StdSomething) > 0 {
		for _, desc := range d.descriptors_StdSomething {
			desc := desc
			calls := 0
			prev := desc.call
			desc.call = func(f *os.File, ints []int) (named bool) {
				calls++
				return prev(f, ints)
			}
			atAssert = append(atAssert, func() (method string, errs []string) {
				err := desc.times(calls)
				if err != nil {
					return "StdSomething", []string{err.Error()}
				}
				return "", nil
			})
		}
		d.m.StdSomething = func(f *os.File, ints ...int) (named bool) {
			var matching []*MyInterfaceInCustomFileStdSomethingMockDescriptor
			var allErrs []specErrs
			for _, desc := range d.descriptors_StdSomething {
				errs := desc.argValidator(f, ints)
				if len(errs) > 0 {
					allErrs = append(allErrs, specErrs{desc.fileLine, errs})
				} else {
					matching = append(matching, desc)
				}
			}
			if len(matching) == 1 {
				return matching[0].call(f, ints)
			}
			var args string
			for i, arg := range []interface{}{f, ints} {
				if i != 0 {
					args += "\n\t"
				}
				args += fmt.Sprintf("%#v", arg)
			}
			if len(matching) == 0 {
				matchingErrs := ""
				for _, errs := range allErrs {
					matchingErrs += "\n\tcandidate described at "+errs.fileLine+":\n"
					for _, err := range errs.errs {
						matchingErrs += "\n\t\t" + err
					}
				}
				panic(fmt.Errorf("no matching candidate for call to mock for MyInterfaceInCustomFile.StdSomething with args:\n\n\t%+v\n\nfailing candidates:\n%s", args, matchingErrs))
			}
			matchingLines := ""
			for _, m := range matching {
				matchingLines += "\n\tcandidate described at " + m.fileLine
			}
			panic(fmt.Errorf("more than one candidate for call to mock for MyInterfaceInCustomFile.StdSomething with args:\n\n\t%+v\n\nmatching candidates:\n%s", args, matchingLines))
		}
	} else {
		d.m.StdSomething = func(f *os.File, ints ...int) (named bool) {
			panic("unexpected call to mock for MyInterfaceInCustomFile.StdSomething")
		}
	}
	return func(t interface{ Errorf(s string, args ...interface{})  }) bool {
		ok := true
		for _, assert := range atAssert {
			method, errs := assert()
			for _, err := range errs {
				ok = false
				t.Errorf("mock for MyInterfaceInCustomFile.%s: %s", method, err)
			}
		}
		return ok
	}
}
	
// Boring starts describing a way method MyInterfaceInCustomFile.Boring is expected to be called
// and what it should return.
//
// You can call it several times to describe different behaviors, each matching different parameters.
func (d MyInterfaceInCustomFileMockDescriptor) Boring() *MyInterfaceInCustomFileBoringMockDescriptor {
	return d.newMyInterfaceInCustomFileBoringMockDescriptor()
}

func (d MyInterfaceInCustomFileMockDescriptor) newMyInterfaceInCustomFileBoringMockDescriptor() *MyInterfaceInCustomFileBoringMockDescriptor {
	_, file, line, _ := runtime.Caller(2)
	return &MyInterfaceInCustomFileBoringMockDescriptor{
		mockDesc: d,
		times: func(int) error { return nil },
		argValidator: func() []string { return nil },
		fileLine: fmt.Sprintf("%s:%d", file, line),
	}
}

// MyInterfaceInCustomFileBoringMockDescriptor is returned by MyInterfaceInCustomFileMockDescriptor.Boring and
// holds methods to describe the mock for method MyInterfaceInCustomFile.Boring.
type MyInterfaceInCustomFileBoringMockDescriptor struct {
	mockDesc MyInterfaceInCustomFileMockDescriptor
	times func(int) error
	argValidator func() []string
	call func()
	fileLine string
}
	
// Times lets you specify a exact number of times this method is expected to be
// called.
func (d *MyInterfaceInCustomFileBoringMockDescriptor) Times(times int) MyInterfaceInCustomFileMockDescriptor {
	return d.TimesMatching(func(got int) error {
		if got != times {
			return fmt.Errorf("expected exactly %d calls, got %d", times, got)
		}
		return nil
	})
}

// AtLeastTimes lets you specify a minimum number of times this method is expected to be
// called.
func (d *MyInterfaceInCustomFileBoringMockDescriptor) AtLeastTimes(times int) MyInterfaceInCustomFileMockDescriptor {
	return d.TimesMatching(func(got int) error {
		if got < times {
			return fmt.Errorf("expected at least %d calls, got %d", times, got)
		}
		return nil
	})
}

// TimesMatching lets you pass a function to accept or reject the number of times
// this method has been called.
func (d *MyInterfaceInCustomFileBoringMockDescriptor) TimesMatching(f func(times int) error) MyInterfaceInCustomFileMockDescriptor {
	d.times = f
	d.done()
	return d.mockDesc
}

// Mock finishes the description and produces a mock.
//
// See MyInterfaceInCustomFileMockDescriptor.Mock for details.
func (d *MyInterfaceInCustomFileBoringMockDescriptor) Mock() (m MyInterfaceInCustomFileMock, assert func(t interface{ Errorf(string, ...interface{})  }) (ok bool)) {
	d.done()
	return d.mockDesc.Mock()
}
	
// Boring finishes the current description for method MyInterfaceInCustomFile.Boring and
// starts describing for method Boring.
//
// See MyInterfaceInCustomFileMockDescriptor.Boring for details.
func (d *MyInterfaceInCustomFileBoringMockDescriptor) Boring() *MyInterfaceInCustomFileBoringMockDescriptor {
	d.done()
	return d.mockDesc.newMyInterfaceInCustomFileBoringMockDescriptor()
}
	
// EmbeddedMethod finishes the current description for method MyInterfaceInCustomFile.Boring and
// starts describing for method EmbeddedMethod.
//
// See MyInterfaceInCustomFileMockDescriptor.EmbeddedMethod for details.
func (d *MyInterfaceInCustomFileBoringMockDescriptor) EmbeddedMethod() *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor {
	d.done()
	return d.mockDesc.newMyInterfaceInCustomFileEmbeddedMethodMockDescriptor()
}
	
// ReturnSomethingAtLeast finishes the current description for method MyInterfaceInCustomFile.Boring and
// starts describing for method ReturnSomethingAtLeast.
//
// See MyInterfaceInCustomFileMockDescriptor.ReturnSomethingAtLeast for details.
func (d *MyInterfaceInCustomFileBoringMockDescriptor) ReturnSomethingAtLeast() *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor {
	d.done()
	return d.mockDesc.newMyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor()
}
	
// ShouldBeFun finishes the current description for method MyInterfaceInCustomFile.Boring and
// starts describing for method ShouldBeFun.
//
// See MyInterfaceInCustomFileMockDescriptor.ShouldBeFun for details.
func (d *MyInterfaceInCustomFileBoringMockDescriptor) ShouldBeFun() *MyInterfaceInCustomFileShouldBeFunMockDescriptor {
	d.done()
	return d.mockDesc.newMyInterfaceInCustomFileShouldBeFunMockDescriptor()
}
	
// StdSomething finishes the current description for method MyInterfaceInCustomFile.Boring and
// starts describing for method StdSomething.
//
// See MyInterfaceInCustomFileMockDescriptor.StdSomething for details.
func (d *MyInterfaceInCustomFileBoringMockDescriptor) StdSomething() *MyInterfaceInCustomFileStdSomethingMockDescriptor {
	d.done()
	return d.mockDesc.newMyInterfaceInCustomFileStdSomethingMockDescriptor()
}
	
func (d *MyInterfaceInCustomFileBoringMockDescriptor) done() {
	d.mockDesc.descriptors_Boring = append(d.mockDesc.descriptors_Boring, d)
}
	
// EmbeddedMethod starts describing a way method MyInterfaceInCustomFile.EmbeddedMethod is expected to be called
// and what it should return.
//
// You can call it several times to describe different behaviors, each matching different parameters.
func (d MyInterfaceInCustomFileMockDescriptor) EmbeddedMethod() *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor {
	return d.newMyInterfaceInCustomFileEmbeddedMethodMockDescriptor()
}

func (d MyInterfaceInCustomFileMockDescriptor) newMyInterfaceInCustomFileEmbeddedMethodMockDescriptor() *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor {
	_, file, line, _ := runtime.Caller(2)
	return &MyInterfaceInCustomFileEmbeddedMethodMockDescriptor{
		mockDesc: d,
		times: func(int) error { return nil },
		argValidator: func() []string { return nil },
		fileLine: fmt.Sprintf("%s:%d", file, line),
	}
}

// MyInterfaceInCustomFileEmbeddedMethodMockDescriptor is returned by MyInterfaceInCustomFileMockDescriptor.EmbeddedMethod and
// holds methods to describe the mock for method MyInterfaceInCustomFile.EmbeddedMethod.
type MyInterfaceInCustomFileEmbeddedMethodMockDescriptor struct {
	mockDesc MyInterfaceInCustomFileMockDescriptor
	times func(int) error
	argValidator func() []string
	call func()
	fileLine string
}
	
// Times lets you specify a exact number of times this method is expected to be
// called.
func (d *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor) Times(times int) MyInterfaceInCustomFileMockDescriptor {
	return d.TimesMatching(func(got int) error {
		if got != times {
			return fmt.Errorf("expected exactly %d calls, got %d", times, got)
		}
		return nil
	})
}

// AtLeastTimes lets you specify a minimum number of times this method is expected to be
// called.
func (d *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor) AtLeastTimes(times int) MyInterfaceInCustomFileMockDescriptor {
	return d.TimesMatching(func(got int) error {
		if got < times {
			return fmt.Errorf("expected at least %d calls, got %d", times, got)
		}
		return nil
	})
}

// TimesMatching lets you pass a function to accept or reject the number of times
// this method has been called.
func (d *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor) TimesMatching(f func(times int) error) MyInterfaceInCustomFileMockDescriptor {
	d.times = f
	d.done()
	return d.mockDesc
}

// Mock finishes the description and produces a mock.
//
// See MyInterfaceInCustomFileMockDescriptor.Mock for details.
func (d *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor) Mock() (m MyInterfaceInCustomFileMock, assert func(t interface{ Errorf(string, ...interface{})  }) (ok bool)) {
	d.done()
	return d.mockDesc.Mock()
}
	
// Boring finishes the current description for method MyInterfaceInCustomFile.EmbeddedMethod and
// starts describing for method Boring.
//
// See MyInterfaceInCustomFileMockDescriptor.Boring for details.
func (d *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor) Boring() *MyInterfaceInCustomFileBoringMockDescriptor {
	d.done()
	return d.mockDesc.newMyInterfaceInCustomFileBoringMockDescriptor()
}
	
// EmbeddedMethod finishes the current description for method MyInterfaceInCustomFile.EmbeddedMethod and
// starts describing for method EmbeddedMethod.
//
// See MyInterfaceInCustomFileMockDescriptor.EmbeddedMethod for details.
func (d *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor) EmbeddedMethod() *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor {
	d.done()
	return d.mockDesc.newMyInterfaceInCustomFileEmbeddedMethodMockDescriptor()
}
	
// ReturnSomethingAtLeast finishes the current description for method MyInterfaceInCustomFile.EmbeddedMethod and
// starts describing for method ReturnSomethingAtLeast.
//
// See MyInterfaceInCustomFileMockDescriptor.ReturnSomethingAtLeast for details.
func (d *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor) ReturnSomethingAtLeast() *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor {
	d.done()
	return d.mockDesc.newMyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor()
}
	
// ShouldBeFun finishes the current description for method MyInterfaceInCustomFile.EmbeddedMethod and
// starts describing for method ShouldBeFun.
//
// See MyInterfaceInCustomFileMockDescriptor.ShouldBeFun for details.
func (d *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor) ShouldBeFun() *MyInterfaceInCustomFileShouldBeFunMockDescriptor {
	d.done()
	return d.mockDesc.newMyInterfaceInCustomFileShouldBeFunMockDescriptor()
}
	
// StdSomething finishes the current description for method MyInterfaceInCustomFile.EmbeddedMethod and
// starts describing for method StdSomething.
//
// See MyInterfaceInCustomFileMockDescriptor.StdSomething for details.
func (d *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor) StdSomething() *MyInterfaceInCustomFileStdSomethingMockDescriptor {
	d.done()
	return d.mockDesc.newMyInterfaceInCustomFileStdSomethingMockDescriptor()
}
	
func (d *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor) done() {
	d.mockDesc.descriptors_EmbeddedMethod = append(d.mockDesc.descriptors_EmbeddedMethod, d)
}
	
// ReturnSomethingAtLeast starts describing a way method MyInterfaceInCustomFile.ReturnSomethingAtLeast is expected to be called
// and what it should return.
//
// You can call it several times to describe different behaviors, each matching different parameters.
func (d MyInterfaceInCustomFileMockDescriptor) ReturnSomethingAtLeast() *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor {
	return d.newMyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor()
}

func (d MyInterfaceInCustomFileMockDescriptor) newMyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor() *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor {
	_, file, line, _ := runtime.Caller(2)
	return &MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor{
		mockDesc: d,
		times: func(int) error { return nil },
		argValidator: func() []string { return nil },
		fileLine: fmt.Sprintf("%s:%d", file, line),
	}
}

// MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor is returned by MyInterfaceInCustomFileMockDescriptor.ReturnSomethingAtLeast and
// holds methods to describe the mock for method MyInterfaceInCustomFile.ReturnSomethingAtLeast.
type MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor struct {
	mockDesc MyInterfaceInCustomFileMockDescriptor
	times func(int) error
	argValidator func() []string
	call func() (r0 int)
	fileLine string
}
	
// Returns lets you specify the values that the mocked method MyInterfaceInCustomFile.ReturnSomethingAtLeast,
// if called with values matching the expectations, will return.
func (d *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor) Returns(r0 int) MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn {
	return d.ReturnsFrom(func() int {
		return r0
	})
}

// Returns lets you specify the values that the mocked method MyInterfaceInCustomFile.ReturnSomethingAtLeast,
// if called with values matching the expectations, will return.
// 
// It passes such passed values to a function that then returns the return values. 
func (d *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor) ReturnsFrom(f func() (r0 int)) MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn {
	d.call = f
	return MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn{d}
}

// MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn is a step forward in the description of a way that
// method MyInterfaceInCustomFile.ReturnSomethingAtLeast is to behave when called, with all expected parameters
// and the resulting values specified.
// arguments specified.
// 
// It has methods to describe the times the method is expected to be called,
// or you can start another method call description, or you can call Mock to
// end the description and get the resulting mock.
type MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn struct {
	methodDesc *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor
}
	
// Times lets you specify a exact number of times this method is expected to be
// called.
func (d MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn) Times(times int) MyInterfaceInCustomFileMockDescriptor {
	return d.TimesMatching(func(got int) error {
		if got != times {
			return fmt.Errorf("expected exactly %d calls, got %d", times, got)
		}
		return nil
	})
}

// AtLeastTimes lets you specify a minimum number of times this method is expected to be
// called.
func (d MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn) AtLeastTimes(times int) MyInterfaceInCustomFileMockDescriptor {
	return d.TimesMatching(func(got int) error {
		if got < times {
			return fmt.Errorf("expected at least %d calls, got %d", times, got)
		}
		return nil
	})
}

// TimesMatching lets you pass a function to accept or reject the number of times
// this method has been called.
func (d MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn) TimesMatching(f func(times int) error) MyInterfaceInCustomFileMockDescriptor {
	d.methodDesc.times = f
	d.methodDesc.done()
	return d.methodDesc.mockDesc
}

// Mock finishes the description and produces a mock.
//
// See MyInterfaceInCustomFileMockDescriptor.Mock for details.
func (d MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn) Mock() (m MyInterfaceInCustomFileMock, assert func(t interface{ Errorf(string, ...interface{})  }) (ok bool)) {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.Mock()
}
	
// Boring finishes the current description for method MyInterfaceInCustomFile.ReturnSomethingAtLeast and
// starts describing for method Boring.
//
// See MyInterfaceInCustomFileMockDescriptor.Boring for details.
func (d MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn) Boring() *MyInterfaceInCustomFileBoringMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileBoringMockDescriptor()
}
	
// EmbeddedMethod finishes the current description for method MyInterfaceInCustomFile.ReturnSomethingAtLeast and
// starts describing for method EmbeddedMethod.
//
// See MyInterfaceInCustomFileMockDescriptor.EmbeddedMethod for details.
func (d MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn) EmbeddedMethod() *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileEmbeddedMethodMockDescriptor()
}
	
// ReturnSomethingAtLeast finishes the current description for method MyInterfaceInCustomFile.ReturnSomethingAtLeast and
// starts describing for method ReturnSomethingAtLeast.
//
// See MyInterfaceInCustomFileMockDescriptor.ReturnSomethingAtLeast for details.
func (d MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn) ReturnSomethingAtLeast() *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor()
}
	
// ShouldBeFun finishes the current description for method MyInterfaceInCustomFile.ReturnSomethingAtLeast and
// starts describing for method ShouldBeFun.
//
// See MyInterfaceInCustomFileMockDescriptor.ShouldBeFun for details.
func (d MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn) ShouldBeFun() *MyInterfaceInCustomFileShouldBeFunMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileShouldBeFunMockDescriptor()
}
	
// StdSomething finishes the current description for method MyInterfaceInCustomFile.ReturnSomethingAtLeast and
// starts describing for method StdSomething.
//
// See MyInterfaceInCustomFileMockDescriptor.StdSomething for details.
func (d MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptorWithReturn) StdSomething() *MyInterfaceInCustomFileStdSomethingMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileStdSomethingMockDescriptor()
}
	
func (d *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor) done() {
	d.mockDesc.descriptors_ReturnSomethingAtLeast = append(d.mockDesc.descriptors_ReturnSomethingAtLeast, d)
}
	
// ShouldBeFun starts describing a way method MyInterfaceInCustomFile.ShouldBeFun is expected to be called
// and what it should return.
//
// You can call it several times to describe different behaviors, each matching different parameters.
func (d MyInterfaceInCustomFileMockDescriptor) ShouldBeFun() *MyInterfaceInCustomFileShouldBeFunMockDescriptor {
	return d.newMyInterfaceInCustomFileShouldBeFunMockDescriptor()
}

func (d MyInterfaceInCustomFileMockDescriptor) newMyInterfaceInCustomFileShouldBeFunMockDescriptor() *MyInterfaceInCustomFileShouldBeFunMockDescriptor {
	_, file, line, _ := runtime.Caller(2)
	return &MyInterfaceInCustomFileShouldBeFunMockDescriptor{
		mockDesc: d,
		times: func(int) error { return nil },
		argValidator: func(got_a0 int, got_a1 map[string]map[MyStruct]bool, got_a2 []chan<- <-chan struct{}) []string { return nil },
		fileLine: fmt.Sprintf("%s:%d", file, line),
	}
}

// MyInterfaceInCustomFileShouldBeFunMockDescriptor is returned by MyInterfaceInCustomFileMockDescriptor.ShouldBeFun and
// holds methods to describe the mock for method MyInterfaceInCustomFile.ShouldBeFun.
type MyInterfaceInCustomFileShouldBeFunMockDescriptor struct {
	mockDesc MyInterfaceInCustomFileMockDescriptor
	times func(int) error
	argValidator func(got_a0 int, got_a1 map[string]map[MyStruct]bool, got_a2 []chan<- <-chan struct{}) []string
	call func(a0 int, a1 map[string]map[MyStruct]bool, a2 []chan<- <-chan struct{}) (r0 int, r1 error)
	fileLine string
}
	
// Takes lets you specify a value with which the actual value passed to
// the mocked method MyInterfaceInCustomFile.ShouldBeFun as parameter #1
// will be compared. 
//
// Package "github.com/google/go-cmp/cmp" is used to do the comparison. You can
// pass extra options for it.
//
// If you want to accept any value, use TakesAny.
//
// If you want more complex validation logic, use TakesMatching.
func (d *MyInterfaceInCustomFileShouldBeFunMockDescriptor) Takes(a0 int, opts ...cmp.Option) MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg {
	prev := d.argValidator
	d.argValidator = func(got_a0 int, got_a1 map[string]map[MyStruct]bool, got_a2 []chan<- <-chan struct{}) []string {
		errMsgs := prev(got_a0, got_a1, got_a2)
		if diff := cmp.Diff(a0, got_a0, opts...); diff != "" {
			errMsgs = append(errMsgs, "parameter #1 mismatch:\n" + diff)
		}
		return errMsgs
	}
	return MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg{d}
}

// TakesAny declares that any value passed to the mocked method
// ShouldBeFun as parameter #1 is expected.
func (d *MyInterfaceInCustomFileShouldBeFunMockDescriptor) TakesAny() MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg {
	return MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg{d}
}

// TakesMatching lets you pass a function to accept or reject the actual
// value passed to the mocked method MyInterfaceInCustomFile.ShouldBeFun as parameter #1.
func (d *MyInterfaceInCustomFileShouldBeFunMockDescriptor) TakesMatching(match func(a0 int) error) MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg {
	prev := d.argValidator
	d.argValidator = func(got_a0 int, got_a1 map[string]map[MyStruct]bool, got_a2 []chan<- <-chan struct{}) []string {
		errMsgs := prev(got_a0, got_a1, got_a2)
		if err := match(got_a0); err != nil {
			errMsgs = append(errMsgs, "parameter \"a0\" custom matcher error: " + err.Error())
		}
		return errMsgs
	}
	return MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg{d}
}

// MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg is a step forward in the description of a way that the
// method MyInterfaceInCustomFile.ShouldBeFun is expected to be called, with 1
// arguments specified.
//
// It has methods to describe the next argument, if there's
// any left, or the return values, if there are any, or the times it's expected
// to be called otherwise.
type MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg struct {
	methodDesc *MyInterfaceInCustomFileShouldBeFunMockDescriptor
}
	
// And lets you specify a value with which the actual value passed to
// the mocked method MyInterfaceInCustomFile.ShouldBeFun as parameter #2
// will be compared. 
//
// Package "github.com/google/go-cmp/cmp" is used to do the comparison. You can
// pass extra options for it.
//
// If you want to accept any value, use AndAny.
//
// If you want more complex validation logic, use AndMatching.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg) And(a1 map[string]map[MyStruct]bool, opts ...cmp.Option) MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args {
	prev := d.methodDesc.argValidator
	d.methodDesc.argValidator = func(got_a0 int, got_a1 map[string]map[MyStruct]bool, got_a2 []chan<- <-chan struct{}) []string {
		errMsgs := prev(got_a0, got_a1, got_a2)
		if diff := cmp.Diff(a1, got_a1, opts...); diff != "" {
			errMsgs = append(errMsgs, "parameter #2 mismatch:\n" + diff)
		}
		return errMsgs
	}
	return MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args{d.methodDesc}
}

// AndAny declares that any value passed to the mocked method
// ShouldBeFun as parameter #2 is expected.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg) AndAny() MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args {
	return MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args{d.methodDesc}
}

// AndMatching lets you pass a function to accept or reject the actual
// value passed to the mocked method MyInterfaceInCustomFile.ShouldBeFun as parameter #2.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWith1Arg) AndMatching(match func(a1 map[string]map[MyStruct]bool) error) MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args {
	prev := d.methodDesc.argValidator
	d.methodDesc.argValidator = func(got_a0 int, got_a1 map[string]map[MyStruct]bool, got_a2 []chan<- <-chan struct{}) []string {
		errMsgs := prev(got_a0, got_a1, got_a2)
		if err := match(got_a1); err != nil {
			errMsgs = append(errMsgs, "parameter \"a1\" custom matcher error: " + err.Error())
		}
		return errMsgs
	}
	return MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args{d.methodDesc}
}

// MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args is a step forward in the description of a way that the
// method MyInterfaceInCustomFile.ShouldBeFun is expected to be called, with 2
// arguments specified.
//
// It has methods to describe the next argument, if there's
// any left, or the return values, if there are any, or the times it's expected
// to be called otherwise.
type MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args struct {
	methodDesc *MyInterfaceInCustomFileShouldBeFunMockDescriptor
}
	
// And lets you specify a value with which the actual value passed to
// the mocked method MyInterfaceInCustomFile.ShouldBeFun as parameter #3
// will be compared. 
//
// Package "github.com/google/go-cmp/cmp" is used to do the comparison. You can
// pass extra options for it.
//
// If you want to accept any value, use AndAny.
//
// If you want more complex validation logic, use AndMatching.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args) And(a2 []chan<- <-chan struct{}, opts ...cmp.Option) MyInterfaceInCustomFileShouldBeFunMockDescriptorWith3Args {
	prev := d.methodDesc.argValidator
	d.methodDesc.argValidator = func(got_a0 int, got_a1 map[string]map[MyStruct]bool, got_a2 []chan<- <-chan struct{}) []string {
		errMsgs := prev(got_a0, got_a1, got_a2)
		if diff := cmp.Diff(a2, got_a2, opts...); diff != "" {
			errMsgs = append(errMsgs, "parameter #3 mismatch:\n" + diff)
		}
		return errMsgs
	}
	return MyInterfaceInCustomFileShouldBeFunMockDescriptorWith3Args{d.methodDesc}
}

// AndAny declares that any value passed to the mocked method
// ShouldBeFun as parameter #3 is expected.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args) AndAny() MyInterfaceInCustomFileShouldBeFunMockDescriptorWith3Args {
	return MyInterfaceInCustomFileShouldBeFunMockDescriptorWith3Args{d.methodDesc}
}

// AndMatching lets you pass a function to accept or reject the actual
// value passed to the mocked method MyInterfaceInCustomFile.ShouldBeFun as parameter #3.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWith2Args) AndMatching(match func(a2 []chan<- <-chan struct{}) error) MyInterfaceInCustomFileShouldBeFunMockDescriptorWith3Args {
	prev := d.methodDesc.argValidator
	d.methodDesc.argValidator = func(got_a0 int, got_a1 map[string]map[MyStruct]bool, got_a2 []chan<- <-chan struct{}) []string {
		errMsgs := prev(got_a0, got_a1, got_a2)
		if err := match(got_a2); err != nil {
			errMsgs = append(errMsgs, "parameter \"a2\" custom matcher error: " + err.Error())
		}
		return errMsgs
	}
	return MyInterfaceInCustomFileShouldBeFunMockDescriptorWith3Args{d.methodDesc}
}

// MyInterfaceInCustomFileShouldBeFunMockDescriptorWith3Args is a step forward in the description of a way that the
// method MyInterfaceInCustomFile.ShouldBeFun is expected to be called, with 3
// arguments specified.
//
// It has methods to describe the next argument, if there's
// any left, or the return values, if there are any, or the times it's expected
// to be called otherwise.
type MyInterfaceInCustomFileShouldBeFunMockDescriptorWith3Args struct {
	methodDesc *MyInterfaceInCustomFileShouldBeFunMockDescriptor
}
	
// Returns lets you specify the values that the mocked method MyInterfaceInCustomFile.ShouldBeFun,
// if called with values matching the expectations, will return.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWith3Args) Returns(r0 int, r1 error) MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn {
	return d.ReturnsFrom(func(int, map[string]map[MyStruct]bool, []chan<- <-chan struct{}) (int, error) {
		return r0, r1
	})
}

// Returns lets you specify the values that the mocked method MyInterfaceInCustomFile.ShouldBeFun,
// if called with values matching the expectations, will return.
// 
// It passes such passed values to a function that then returns the return values. 
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWith3Args) ReturnsFrom(f func(a0 int, a1 map[string]map[MyStruct]bool, a2 []chan<- <-chan struct{}) (r0 int, r1 error)) MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn {
	d.methodDesc.call = f
	return MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn{d.methodDesc}
}

// MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn is a step forward in the description of a way that
// method MyInterfaceInCustomFile.ShouldBeFun is to behave when called, with all expected parameters
// and the resulting values specified.
// arguments specified.
// 
// It has methods to describe the times the method is expected to be called,
// or you can start another method call description, or you can call Mock to
// end the description and get the resulting mock.
type MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn struct {
	methodDesc *MyInterfaceInCustomFileShouldBeFunMockDescriptor
}
	
// Times lets you specify a exact number of times this method is expected to be
// called.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn) Times(times int) MyInterfaceInCustomFileMockDescriptor {
	return d.TimesMatching(func(got int) error {
		if got != times {
			return fmt.Errorf("expected exactly %d calls, got %d", times, got)
		}
		return nil
	})
}

// AtLeastTimes lets you specify a minimum number of times this method is expected to be
// called.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn) AtLeastTimes(times int) MyInterfaceInCustomFileMockDescriptor {
	return d.TimesMatching(func(got int) error {
		if got < times {
			return fmt.Errorf("expected at least %d calls, got %d", times, got)
		}
		return nil
	})
}

// TimesMatching lets you pass a function to accept or reject the number of times
// this method has been called.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn) TimesMatching(f func(times int) error) MyInterfaceInCustomFileMockDescriptor {
	d.methodDesc.times = f
	d.methodDesc.done()
	return d.methodDesc.mockDesc
}

// Mock finishes the description and produces a mock.
//
// See MyInterfaceInCustomFileMockDescriptor.Mock for details.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn) Mock() (m MyInterfaceInCustomFileMock, assert func(t interface{ Errorf(string, ...interface{})  }) (ok bool)) {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.Mock()
}
	
// Boring finishes the current description for method MyInterfaceInCustomFile.ShouldBeFun and
// starts describing for method Boring.
//
// See MyInterfaceInCustomFileMockDescriptor.Boring for details.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn) Boring() *MyInterfaceInCustomFileBoringMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileBoringMockDescriptor()
}
	
// EmbeddedMethod finishes the current description for method MyInterfaceInCustomFile.ShouldBeFun and
// starts describing for method EmbeddedMethod.
//
// See MyInterfaceInCustomFileMockDescriptor.EmbeddedMethod for details.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn) EmbeddedMethod() *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileEmbeddedMethodMockDescriptor()
}
	
// ReturnSomethingAtLeast finishes the current description for method MyInterfaceInCustomFile.ShouldBeFun and
// starts describing for method ReturnSomethingAtLeast.
//
// See MyInterfaceInCustomFileMockDescriptor.ReturnSomethingAtLeast for details.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn) ReturnSomethingAtLeast() *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor()
}
	
// ShouldBeFun finishes the current description for method MyInterfaceInCustomFile.ShouldBeFun and
// starts describing for method ShouldBeFun.
//
// See MyInterfaceInCustomFileMockDescriptor.ShouldBeFun for details.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn) ShouldBeFun() *MyInterfaceInCustomFileShouldBeFunMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileShouldBeFunMockDescriptor()
}
	
// StdSomething finishes the current description for method MyInterfaceInCustomFile.ShouldBeFun and
// starts describing for method StdSomething.
//
// See MyInterfaceInCustomFileMockDescriptor.StdSomething for details.
func (d MyInterfaceInCustomFileShouldBeFunMockDescriptorWithReturn) StdSomething() *MyInterfaceInCustomFileStdSomethingMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileStdSomethingMockDescriptor()
}
	
func (d *MyInterfaceInCustomFileShouldBeFunMockDescriptor) done() {
	d.mockDesc.descriptors_ShouldBeFun = append(d.mockDesc.descriptors_ShouldBeFun, d)
}
	
// StdSomething starts describing a way method MyInterfaceInCustomFile.StdSomething is expected to be called
// and what it should return.
//
// You can call it several times to describe different behaviors, each matching different parameters.
func (d MyInterfaceInCustomFileMockDescriptor) StdSomething() *MyInterfaceInCustomFileStdSomethingMockDescriptor {
	return d.newMyInterfaceInCustomFileStdSomethingMockDescriptor()
}

func (d MyInterfaceInCustomFileMockDescriptor) newMyInterfaceInCustomFileStdSomethingMockDescriptor() *MyInterfaceInCustomFileStdSomethingMockDescriptor {
	_, file, line, _ := runtime.Caller(2)
	return &MyInterfaceInCustomFileStdSomethingMockDescriptor{
		mockDesc: d,
		times: func(int) error { return nil },
		argValidator: func(got_f *os.File, got_ints []int) []string { return nil },
		fileLine: fmt.Sprintf("%s:%d", file, line),
	}
}

// MyInterfaceInCustomFileStdSomethingMockDescriptor is returned by MyInterfaceInCustomFileMockDescriptor.StdSomething and
// holds methods to describe the mock for method MyInterfaceInCustomFile.StdSomething.
type MyInterfaceInCustomFileStdSomethingMockDescriptor struct {
	mockDesc MyInterfaceInCustomFileMockDescriptor
	times func(int) error
	argValidator func(got_f *os.File, got_ints []int) []string
	call func(f *os.File, ints []int) (named bool)
	fileLine string
}
	
// Takes lets you specify a value with which the actual value passed to
// the mocked method MyInterfaceInCustomFile.StdSomething as parameter #1
// will be compared. 
//
// Package "github.com/google/go-cmp/cmp" is used to do the comparison. You can
// pass extra options for it.
//
// If you want to accept any value, use TakesAny.
//
// If you want more complex validation logic, use TakesMatching.
func (d *MyInterfaceInCustomFileStdSomethingMockDescriptor) Takes(f *os.File, opts ...cmp.Option) MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg {
	prev := d.argValidator
	d.argValidator = func(got_f *os.File, got_ints []int) []string {
		errMsgs := prev(got_f, got_ints)
		if diff := cmp.Diff(f, got_f, opts...); diff != "" {
			errMsgs = append(errMsgs, "parameter #1 mismatch:\n" + diff)
		}
		return errMsgs
	}
	return MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg{d}
}

// TakesAny declares that any value passed to the mocked method
// StdSomething as parameter #1 is expected.
func (d *MyInterfaceInCustomFileStdSomethingMockDescriptor) TakesAny() MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg {
	return MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg{d}
}

// TakesMatching lets you pass a function to accept or reject the actual
// value passed to the mocked method MyInterfaceInCustomFile.StdSomething as parameter #1.
func (d *MyInterfaceInCustomFileStdSomethingMockDescriptor) TakesMatching(match func(f *os.File) error) MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg {
	prev := d.argValidator
	d.argValidator = func(got_f *os.File, got_ints []int) []string {
		errMsgs := prev(got_f, got_ints)
		if err := match(got_f); err != nil {
			errMsgs = append(errMsgs, "parameter \"f\" custom matcher error: " + err.Error())
		}
		return errMsgs
	}
	return MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg{d}
}

// MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg is a step forward in the description of a way that the
// method MyInterfaceInCustomFile.StdSomething is expected to be called, with 1
// arguments specified.
//
// It has methods to describe the next argument, if there's
// any left, or the return values, if there are any, or the times it's expected
// to be called otherwise.
type MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg struct {
	methodDesc *MyInterfaceInCustomFileStdSomethingMockDescriptor
}
	
// And lets you specify a value with which the actual value passed to
// the mocked method MyInterfaceInCustomFile.StdSomething as parameter #2
// will be compared. 
//
// Package "github.com/google/go-cmp/cmp" is used to do the comparison. You can
// pass extra options for it.
//
// If you want to accept any value, use AndAny.
//
// If you want more complex validation logic, use AndMatching.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg) And(ints []int, opts ...cmp.Option) MyInterfaceInCustomFileStdSomethingMockDescriptorWith2Args {
	prev := d.methodDesc.argValidator
	d.methodDesc.argValidator = func(got_f *os.File, got_ints []int) []string {
		errMsgs := prev(got_f, got_ints)
		if diff := cmp.Diff(ints, got_ints, opts...); diff != "" {
			errMsgs = append(errMsgs, "parameter #2 mismatch:\n" + diff)
		}
		return errMsgs
	}
	return MyInterfaceInCustomFileStdSomethingMockDescriptorWith2Args{d.methodDesc}
}

// AndAny declares that any value passed to the mocked method
// StdSomething as parameter #2 is expected.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg) AndAny() MyInterfaceInCustomFileStdSomethingMockDescriptorWith2Args {
	return MyInterfaceInCustomFileStdSomethingMockDescriptorWith2Args{d.methodDesc}
}

// AndMatching lets you pass a function to accept or reject the actual
// value passed to the mocked method MyInterfaceInCustomFile.StdSomething as parameter #2.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWith1Arg) AndMatching(match func(ints []int) error) MyInterfaceInCustomFileStdSomethingMockDescriptorWith2Args {
	prev := d.methodDesc.argValidator
	d.methodDesc.argValidator = func(got_f *os.File, got_ints []int) []string {
		errMsgs := prev(got_f, got_ints)
		if err := match(got_ints); err != nil {
			errMsgs = append(errMsgs, "parameter \"ints\" custom matcher error: " + err.Error())
		}
		return errMsgs
	}
	return MyInterfaceInCustomFileStdSomethingMockDescriptorWith2Args{d.methodDesc}
}

// MyInterfaceInCustomFileStdSomethingMockDescriptorWith2Args is a step forward in the description of a way that the
// method MyInterfaceInCustomFile.StdSomething is expected to be called, with 2
// arguments specified.
//
// It has methods to describe the next argument, if there's
// any left, or the return values, if there are any, or the times it's expected
// to be called otherwise.
type MyInterfaceInCustomFileStdSomethingMockDescriptorWith2Args struct {
	methodDesc *MyInterfaceInCustomFileStdSomethingMockDescriptor
}
	
// Returns lets you specify the values that the mocked method MyInterfaceInCustomFile.StdSomething,
// if called with values matching the expectations, will return.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWith2Args) Returns(named bool) MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn {
	return d.ReturnsFrom(func(*os.File, []int) bool {
		return named
	})
}

// Returns lets you specify the values that the mocked method MyInterfaceInCustomFile.StdSomething,
// if called with values matching the expectations, will return.
// 
// It passes such passed values to a function that then returns the return values. 
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWith2Args) ReturnsFrom(f func(f *os.File, ints []int) (named bool)) MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn {
	d.methodDesc.call = f
	return MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn{d.methodDesc}
}

// MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn is a step forward in the description of a way that
// method MyInterfaceInCustomFile.StdSomething is to behave when called, with all expected parameters
// and the resulting values specified.
// arguments specified.
// 
// It has methods to describe the times the method is expected to be called,
// or you can start another method call description, or you can call Mock to
// end the description and get the resulting mock.
type MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn struct {
	methodDesc *MyInterfaceInCustomFileStdSomethingMockDescriptor
}
	
// Times lets you specify a exact number of times this method is expected to be
// called.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn) Times(times int) MyInterfaceInCustomFileMockDescriptor {
	return d.TimesMatching(func(got int) error {
		if got != times {
			return fmt.Errorf("expected exactly %d calls, got %d", times, got)
		}
		return nil
	})
}

// AtLeastTimes lets you specify a minimum number of times this method is expected to be
// called.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn) AtLeastTimes(times int) MyInterfaceInCustomFileMockDescriptor {
	return d.TimesMatching(func(got int) error {
		if got < times {
			return fmt.Errorf("expected at least %d calls, got %d", times, got)
		}
		return nil
	})
}

// TimesMatching lets you pass a function to accept or reject the number of times
// this method has been called.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn) TimesMatching(f func(times int) error) MyInterfaceInCustomFileMockDescriptor {
	d.methodDesc.times = f
	d.methodDesc.done()
	return d.methodDesc.mockDesc
}

// Mock finishes the description and produces a mock.
//
// See MyInterfaceInCustomFileMockDescriptor.Mock for details.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn) Mock() (m MyInterfaceInCustomFileMock, assert func(t interface{ Errorf(string, ...interface{})  }) (ok bool)) {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.Mock()
}
	
// Boring finishes the current description for method MyInterfaceInCustomFile.StdSomething and
// starts describing for method Boring.
//
// See MyInterfaceInCustomFileMockDescriptor.Boring for details.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn) Boring() *MyInterfaceInCustomFileBoringMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileBoringMockDescriptor()
}
	
// EmbeddedMethod finishes the current description for method MyInterfaceInCustomFile.StdSomething and
// starts describing for method EmbeddedMethod.
//
// See MyInterfaceInCustomFileMockDescriptor.EmbeddedMethod for details.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn) EmbeddedMethod() *MyInterfaceInCustomFileEmbeddedMethodMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileEmbeddedMethodMockDescriptor()
}
	
// ReturnSomethingAtLeast finishes the current description for method MyInterfaceInCustomFile.StdSomething and
// starts describing for method ReturnSomethingAtLeast.
//
// See MyInterfaceInCustomFileMockDescriptor.ReturnSomethingAtLeast for details.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn) ReturnSomethingAtLeast() *MyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileReturnSomethingAtLeastMockDescriptor()
}
	
// ShouldBeFun finishes the current description for method MyInterfaceInCustomFile.StdSomething and
// starts describing for method ShouldBeFun.
//
// See MyInterfaceInCustomFileMockDescriptor.ShouldBeFun for details.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn) ShouldBeFun() *MyInterfaceInCustomFileShouldBeFunMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileShouldBeFunMockDescriptor()
}
	
// StdSomething finishes the current description for method MyInterfaceInCustomFile.StdSomething and
// starts describing for method StdSomething.
//
// See MyInterfaceInCustomFileMockDescriptor.StdSomething for details.
func (d MyInterfaceInCustomFileStdSomethingMockDescriptorWithReturn) StdSomething() *MyInterfaceInCustomFileStdSomethingMockDescriptor {
	d.methodDesc.done()
	return d.methodDesc.mockDesc.newMyInterfaceInCustomFileStdSomethingMockDescriptor()
}
	
func (d *MyInterfaceInCustomFileStdSomethingMockDescriptor) done() {
	d.mockDesc.descriptors_StdSomething = append(d.mockDesc.descriptors_StdSomething, d)
}
	
// Mock returns a mock for MyInterface that calls the functions
// defined as struct fields in the receiver.
//
// You probably want to use Describe instead.
func (m *MyInterfaceInCustomFileMocker) Mock() MyInterfaceInCustomFileMock {
	return _makegomock_MyInterfaceInCustomFileMockFromMocker{m}
}

type _makegomock_MyInterfaceInCustomFileMockFromMocker struct {
	m *MyInterfaceInCustomFileMocker
}

func (m _makegomock_MyInterfaceInCustomFileMockFromMocker) Boring() {
	m.m.Boring()
}

func (m _makegomock_MyInterfaceInCustomFileMockFromMocker) EmbeddedMethod() {
	m.m.EmbeddedMethod()
}

func (m _makegomock_MyInterfaceInCustomFileMockFromMocker) ReturnSomethingAtLeast() (r0 int) {
	return m.m.ReturnSomethingAtLeast()
}

func (m _makegomock_MyInterfaceInCustomFileMockFromMocker) ShouldBeFun(a0 int, a1 map[string]map[MyStruct]bool, a2 ...chan<- <-chan struct{}) (r0 int, r1 error) {
	return m.m.ShouldBeFun(a0, a1, a2...)
}

func (m _makegomock_MyInterfaceInCustomFileMockFromMocker) StdSomething(f *os.File, ints ...int) (named bool) {
	return m.m.StdSomething(f, ints...)
}

// MyInterfaceInCustomFileMock is a mock with the same underlying type as MyInterface.
//
// It is copied from the original just to avoid introducing a dependency on
// MyInterface's package.
type MyInterfaceInCustomFileMock interface {
	Boring()
	EmbeddedMethod()
	ReturnSomethingAtLeast() (r0 int)
	ShouldBeFun(a0 int, a1 map[string]map[MyStruct]bool, a2 ...chan<- <-chan struct{}) (r0 int, r1 error)
	StdSomething(f *os.File, ints ...int) (named bool)
}
