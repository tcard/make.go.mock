package makegomock

import (
	"bytes"
	"fmt"
	"go/types"
	"io"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"text/tabwriter"

	"golang.org/x/tools/go/packages"
)

// GenerateToFileFromFile is a convenience function that combines Resolve,
// Generate and operations on the file system to write the generated mock code
// to a file.
func GenerateToFileFromFile(
	dstFileOrDirPath,
	dstPkgName,
	dstTypeName,
	srcPath,
	srcPkgName,
	srcTypeName string,
	bare bool,
) (dstFilePath string, err error) {
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.LoadTypes,
	}, "file="+srcPath)
	if err != nil {
		return "", fmt.Errorf("loading Go file at %s: %s", srcPath, err)
	}

	var srcPkg *packages.Package
	for _, p := range pkgs {
		if p.Name == srcPkgName {
			srcPkg = p
		}
	}
	if srcPkg == nil {
		return "", fmt.Errorf("didn't load package %q", srcPkgName)
	}
	if len(srcPkg.Errors) > 0 {
		if err != nil {
			errs := make([]error, 0, len(srcPkg.Errors))
			for _, err := range srcPkg.Errors {
				errs = append(errs, err)
			}
			return "", Errors{fmt.Errorf("loading package %q failed", srcPkgName), errs}
		}
	}

	var dstImportPath string
	dstFilePath, dstPkgName, dstImportPath, dstTypeName, err = Resolve(
		dstFileOrDirPath,
		dstPkgName,
		dstTypeName,
		srcPkgName,
		srcPkg.PkgPath,
		srcTypeName,
	)
	if err != nil {
		return "", err
	}

	typ, ok := srcPkg.Types.Scope().Lookup(srcTypeName).(*types.TypeName)
	if !ok {
		return "", fmt.Errorf("type %q not found in package %q", srcTypeName, srcPkgName)
	}

	var generated bytes.Buffer

	err = Generate(&generated, typ.Type().(*types.Named), dstPkgName, dstImportPath, dstTypeName, bare)
	if err != nil {
		return "", fmt.Errorf("generating code: %s", err)
	}

	dstDir := filepath.Dir(dstFilePath)
	err = os.MkdirAll(dstDir, 0755)
	if err != nil {
		return "", fmt.Errorf("creating destination directory at %s: %s", dstDir, err)
	}

	f, err := os.Create(dstFilePath)
	if err != nil {
		return "", fmt.Errorf("creating destination file at %s: %s", dstFilePath, err)
	}
	defer f.Close()

	_, err = io.Copy(f, &generated)
	if err != nil {
		return "", fmt.Errorf("writing into %s: %s", dstFilePath, err)
	}

	return dstFilePath, nil
}

// Errors is an error caused by multiple errors.
type Errors struct {
	Err  error
	Errs []error
}

// Error implements error.
func (errs Errors) Error() string {
	msgs := make([]string, 0, len(errs.Errs))
	for _, err := range errs.Errs {
		msgs = append(msgs, err.Error())
	}
	return fmt.Sprintf("%s (errors: %s)", errs.Err, strings.Join(msgs, ";"))
}

// Resolve resolves the destination file path, package name and import path.
//
// If dstPkgName is empty, pkgName will be the name of the destination
// directory, or srcPkgName if the destination directory is the current
// directory.
//
// The destination directory is resolved from dstFileOrDirPath. If empty, the
// current directory is used. If a path to what looks like a Go source file,
// its base directory is used. Otherwise, it is taken to be the explicit path
// to the destination directory.
//
// If dstFileOrDirPath didn't specify a destination Go source file, filePath
// is resolved from typeName by  prefixing with 'mock_' and suffixing with
// '_test.go'.
//
// If dstTypeName is left empty, srcTypeName is used.
//
// The import path is resolved from the destination directory and srcImportPath.
// The destination directory must be resolved to a path that is under
// srcImportPath.
func Resolve(
	dstFileOrDirPath,
	dstPkgName,
	dstTypeName,
	srcPkgName,
	srcImportPath,
	srcTypeName string,
) (filePath, pkgName, importPath, typeName string, err error) {
	typeName = resolveTypeName(dstTypeName, srcTypeName)
	filePath, err = resolveFilePath(dstFileOrDirPath, typeName)
	if err != nil {
		return
	}
	pkgName = resolvePkgName(dstPkgName, dstFileOrDirPath, srcPkgName)
	importPath, err = resolveImportPath(filePath, srcImportPath)
	return
}

func resolveTypeName(dstTypeName, srcTypeName string) string {
	typeName := dstTypeName
	if typeName == "" {
		typeName = srcTypeName
	}
	return typeName
}

func resolveFilePath(dstFileOrDirPath, dstTypeName string) (string, error) {
	filePath := dstFileOrDirPath
	if filepath.Ext(filePath) != ".go" {
		filePath = filepath.Join(filePath, "mock_"+dstTypeName+"_test.go")
	}
	return filepath.Clean(filePath), nil
}

func resolvePkgName(dstPkgName, dstFileOrDirPath, srcPkgName string) string {
	pkgName := dstPkgName
	if pkgName == "" {
		if dstFileOrDirPath == "" {
			pkgName = srcPkgName
		} else {
			pkgName = filepath.Base(filepath.Dir(dstFileOrDirPath))
			if pkgName == "." {
				pkgName = srcPkgName
			}
		}
	}
	return pkgName
}

func resolveImportPath(filePath, srcImportPath string) (string, error) {
	dstDir := filepath.Dir(filePath)
	importPath := path.Join(srcImportPath, filepath.ToSlash(dstDir))
	if !strings.HasPrefix(importPath, srcImportPath) {
		return "", fmt.Errorf("resolved import path %q from destination directory %s which is not inside import path %q", importPath, dstDir, srcImportPath)
	}
	return importPath, nil
}

// Generate generates mock code into w that mocks the specified type in a Go
// source file at the given package name and import path.
//
// If rename is empty, the generated type name will be based on typ.
func Generate(w io.Writer, typ *types.Named, pkgName, importPath, rename string, bare bool) error {
	methods, imports, err := inspectType(typ, pkgName, importPath)
	if err != nil {
		return err
	}

	_, err = io.WriteString(w, `// Code generated by github.com/tcard/make.go.mock. DO NOT EDIT.

package `+pkgName+`
`)
	if err != nil {
		return err
	}

	name := typ.Obj().Name()
	if rename == "" {
		rename = name
	}

	g := &generator{
		w:         w,
		typ:       typ,
		name:      name,
		rename:    rename,
		methods:   methods,
		imports:   imports,
		qualifier: imports.qualifier,
		bare:      bare,
	}

	return g.generate()
}

type generator struct {
	w          io.Writer
	typ        *types.Named
	name       string
	rename     string
	methods    []method
	imports    *importsSet
	qualifier  types.Qualifier
	cmpPkg     string
	fmtPkg     string
	runtimePkg string
	bare       bool
}

func (g *generator) generate() error {
	err := g.generateImports()
	if err != nil {
		return err
	}

	err = g.generateMockerStruct()
	if err != nil {
		return err
	}

	if !g.bare {
		err = g.generateDescribeMethod()
		if err != nil {
			return err
		}
	}

	err = g.generateMockMethod()
	if err != nil {
		return err
	}

	err = g.generateTypeCopy()
	if err != nil {
		return err
	}

	return nil
}

func (g *generator) generateImports() error {
	if !g.bare {
		g.cmpPkg = g.imports.addIfNotPresent("cmp", "github.com/google/go-cmp/cmp")
		g.fmtPkg = g.imports.addIfNotPresent("fmt", "fmt")
		g.runtimePkg = g.imports.addIfNotPresent("runtime", "runtime")
	}

	orderedImps := g.imports.ordered()
	if len(orderedImps) == 0 {
		return nil
	}

	_, err := io.WriteString(g.w, `
import (`)
	if err != nil {
		return err
	}

	for _, imp := range orderedImps {
		s := `"` + imp.path + `"`
		if imp.qualifier != "" {
			s = imp.qualifier + " " + s
		}
		_, err = io.WriteString(g.w, `
	`+s)
		if err != nil {
			return err
		}
	}

	_, err = io.WriteString(g.w, `
)
`)
	return err
}

func inspectType(typ *types.Named, pkgName, importPath string) ([]method, *importsSet, error) {
	imports := importsSet{pkgName: pkgName, importPath: importPath}
	switch utyp := typ.Underlying().(type) {
	case *types.Signature:
		sig := inspectSignature(utyp, &imports)
		return []method{{name: "Func", sig: sig}}, &imports, nil
	case *types.Interface:
		methods := inspectInterface(utyp, &imports)
		return methods, &imports, nil
	default:
		return nil, nil, fmt.Errorf("expected type %s (%T) to be a function or interface", typ.Obj().Name(), typ)
	}
}

type method struct {
	name string
	sig  signature
}

type signature struct {
	args     []argument
	variadic *argument
	ret      []argument
}

type argument struct {
	name string
	typ  string
}

type impor struct {
	qualifier string
	path      string
}

type importsSet struct {
	pkgName    string
	importPath string

	byPath     map[string]impor
	qualifiers map[string]struct{}
}

func (set *importsSet) qualifier(pkg *types.Package) string {
	if pkg.Path() == set.importPath && pkg.Name() == set.pkgName {
		return ""
	}

	if impor, ok := set.byPath[pkg.Path()]; ok {
		return impor.qualifier
	}

	suffix := 0
	qualifier := pkg.Name()
	for _, used := set.qualifiers[qualifier]; used; _, used = set.qualifiers[qualifier] {
		suffix++
		qualifier = fmt.Sprintf("%s%d", pkg.Name(), suffix)
	}
	i := impor{qualifier, pkg.Path()}

	if set.byPath == nil {
		set.byPath = make(map[string]impor)
	}
	set.byPath[pkg.Path()] = i
	if set.qualifiers == nil {
		set.qualifiers = make(map[string]struct{})
	}
	set.qualifiers[qualifier] = struct{}{}

	return qualifier
}

func (set *importsSet) addIfNotPresent(qualifier, path string) string {
	if prev, ok := set.byPath[path]; ok {
		return prev.qualifier
	}
	if set.byPath == nil {
		set.byPath = make(map[string]impor)
	}
	set.byPath[path] = impor{qualifier: qualifier, path: path}
	return qualifier
}

func (set *importsSet) ordered() []impor {
	is := make([]impor, 0, len(set.byPath))
	for _, i := range set.byPath {
		is = append(is, i)
	}
	sort.Slice(is, func(i, j int) bool {
		return strings.Compare(is[i].path, is[j].path) < 0
	})
	return is
}

func inspectSignature(sig *types.Signature, imports *importsSet) signature {
	var s signature
	params := sig.Params()
	i := 0
	for ; i < params.Len(); i++ {
		param := params.At(i)
		if i == params.Len()-1 && sig.Variadic() {
			arg := inspectArg("a", i, param, imports, true)
			s.variadic = &arg
		} else {
			s.args = append(s.args, inspectArg("a", i, param, imports, false))
		}
	}
	results := sig.Results()
	for i := 0; i < results.Len(); i++ {
		result := results.At(i)
		s.ret = append(s.ret, inspectArg("r", i, result, imports, false))
	}
	return s
}

func inspectArg(defaultPrefix string, i int, arg *types.Var, imports *importsSet, variadic bool) argument {
	typ := arg.Type()
	if variadic {
		typ = typ.Underlying().(*types.Slice).Elem()
	}
	name := arg.Name()
	if name == "" {
		name = fmt.Sprintf("%s%d", defaultPrefix, i)
	}
	return argument{
		name: name,
		typ:  types.TypeString(typ, imports.qualifier),
	}
}

func inspectInterface(typ *types.Interface, imports *importsSet) []method {
	methods := make([]method, 0, typ.NumMethods())
	for i := 0; i < typ.NumMethods(); i++ {
		m := typ.Method(i)
		typ := inspectSignature(m.Type().(*types.Signature), imports)
		methods = append(methods, method{m.Name(), typ})
	}
	return methods
}

func (g *generator) generateMockerStruct() error {
	maybeDescribe := ""
	if !g.bare {
		maybeDescribe = `
//
// The Describe method is a shortcut to define this struct's fields in a
// declarative manner.`
	}

	mockerName := g.rename + "Mocker"
	_, err := io.WriteString(g.w, `
// `+mockerName+` builds mocks for type `+g.name+`.
//
// Its fields match the original type's methods. Set those you expect to be
// called, then call the Mock method to get a mock that implements the original
// type.
//
// If the original type was a function, it is mapped to field Func.`+maybeDescribe+`
type `+mockerName+` struct {`)
	if err != nil {
		return err
	}

	if len(g.methods) > 0 {
		_, err := io.WriteString(g.w, `
`)
		if err != nil {
			return err
		}
	}

	tw := tabwriter.NewWriter(g.w, 0, 0, 1, ' ', tabwriter.TabIndent|tabwriter.StripEscape)
	for _, method := range g.methods {
		_, err := io.WriteString(tw, "\xff\t\xff"+method.name+`	func`+sigStr(method.sig, true)+`
`)
		if err != nil {
			return err
		}
	}
	err = tw.Flush()
	if err != nil {
		return err
	}

	_, err = io.WriteString(g.w, `}
`)

	return err
}

func sigStr(sig signature, spread bool) string {
	argsStr := argsStr(sig.args, sig.variadic, spread)
	retStr := ""
	if len(sig.ret) > 0 {
		retStrs := make([]string, 0, len(sig.ret)+1)
		for _, arg := range sig.ret {
			retStrs = append(retStrs, argStr(arg, false, false))
		}
		retStr = strings.Join(retStrs, ", ")
		if len(sig.ret) > 1 || sig.ret[0].name != "" {
			retStr = "(" + retStr + ")"
		}
		retStr = " " + retStr
	}
	return "(" + argsStr + ")" + retStr
}

func sigStrNoNames(sig signature, spread bool) string {
	for _, orig := range []*[]argument{&sig.args, &sig.ret} {
		args := make([]argument, 0, len(*orig))
		for _, arg := range *orig {
			arg.name = ""
			args = append(args, arg)
		}
		*orig = args
	}

	if sig.variadic != nil {
		arg := *sig.variadic
		arg.name = ""
		sig.variadic = &arg
	}

	return sigStr(sig, spread)
}

func argsStr(args []argument, variadic *argument, spread bool) string {
	argsStrs := make([]string, 0, len(args)+1)
	for _, arg := range args {
		argsStrs = append(argsStrs, argStr(arg, false, false))
	}
	if variadic != nil {
		argsStrs = append(argsStrs, argStr(*variadic, true, spread))
	}
	return strings.Join(argsStrs, ", ")
}

func argStr(arg argument, variadic, spread bool) string {
	parts := make([]string, 0, 2)
	if arg.name != "" {
		parts = append(parts, arg.name)
	}
	if variadic {
		if spread {
			arg.typ = "..." + arg.typ
		} else {
			arg.typ = "[]" + arg.typ
		}
	}
	if arg.typ != "" {
		parts = append(parts, arg.typ)
	}
	return strings.Join(parts, " ")
}

func (g *generator) generateMockMethod() error {
	maybeDescribe := ""
	if !g.bare {
		maybeDescribe = `
//
// You probably want to use Describe instead.`
	}
	mockerName := g.rename + "Mocker"
	mockName := g.rename + "Mock"
	_, err := io.WriteString(g.w, `
// Mock returns a mock for `+g.typ.Obj().Name()+` that calls the functions
// defined as struct fields in the receiver.`+maybeDescribe+`
func (m *`+mockerName+`) Mock() `+mockName+` {`)
	if err != nil {
		return err
	}

	switch g.typ.Underlying().(type) {
	case *types.Signature:
		_, err := io.WriteString(g.w, `
	return m.Func
}
`)
		return err
	case *types.Interface:
		_, err := io.WriteString(g.w, `
	return _makegomock_`+g.rename+`MockFromMocker{m}
}

type _makegomock_`+g.rename+`MockFromMocker struct {
	m *`+mockerName+`
}
`)
		if err != nil {
			return err
		}

		for _, m := range g.methods {
			maybeReturn := ""
			if len(m.sig.ret) > 0 {
				maybeReturn = "return "
			}
			_, err := io.WriteString(g.w, `
func (m _makegomock_`+g.rename+`MockFromMocker) `+m.name+sigStr(m.sig, true)+` {
	`+maybeReturn+`m.m.`+m.name+`(`+argsForCall(m.sig.args, m.sig.variadic, true)+`)
}
`)
			if err != nil {
				return err
			}
		}

		return nil
	}

	panic("unreachable")
}

func (g *generator) generateTypeCopy() error {
	mockName := g.rename + "Mock"
	_, err := io.WriteString(g.w, `
// `+mockName+` is a mock with the same underlying type as `+g.typ.Obj().Name()+`.
//
// It is copied from the original just to avoid introducing a dependency on
// `+g.typ.Obj().Name()+`'s package.
type `+mockName+` `)
	if err != nil {
		return err
	}

	switch typ := g.typ.Underlying().(type) {
	case *types.Signature:
		_, err := io.WriteString(g.w, types.TypeString(typ, g.qualifier)+"\n")
		return err
	case *types.Interface:
		_, err := io.WriteString(g.w, `interface {`)
		if err != nil {
			return err
		}

		if !typ.Empty() {
			_, err := io.WriteString(g.w, `
`)
			if err != nil {
				return err
			}
		}

		tw := tabwriter.NewWriter(g.w, 0, 0, 1, ' ', tabwriter.TabIndent|tabwriter.StripEscape)
		for _, m := range g.methods {
			_, err := io.WriteString(tw, "\xff\t\xff"+m.name+sigStr(m.sig, true))
			if err != nil {
				return err
			}

			_, err = io.WriteString(tw, `
`)
			if err != nil {
				return err
			}
		}
		err = tw.Flush()
		if err != nil {
			return err
		}

		_, err = io.WriteString(g.w, `}
`)

		return err
	}
	panic("unreachable")
}
